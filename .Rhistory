## DGP of I(1) and I(0) mixed VECM
plot(ts(RR$Y))
RR$GABtest$LR
1-pchisq(ABtest$LR,14)   ### The Ho of last two are I(0) can be rejected
RR <- MIxCIVARData(n=9,p=2,T=209,r=5,k=2,type="const",Bo=NA,Y=NA,D=NA)
## DGP of I(1) and I(0) mixed VECM
plot(ts(RR$Y))
#### testing the mixed VECM via testing the restrictions on beta
res_d <- CIVARData(n=9,p=2,T=209,type="const",crk=4)
res_e = CIVARest(res=res_d)
res_e$Summary
n = 9; crk = 4; k = 2; r = 5
CC  <- c(8,9,17,18)
GG  <- c(19:25,28:34)
G = diag(n*crk); psi=matrix(1,n*crk,1)
### this implies there is no restrictions on the adjustment coefficients alpha
H = diag(n*crk);              H2 = H[,-c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n),CC,GG)]
#### only normalization
h = matrix(0,n*crk,1);         h[c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n)),1] <- 1
phi = matrix(1,ncol(H2),1)
## check consistency of the restrictions    G%*%psi; H2%*%phi + h
#
G%*%psi; H2%*%phi + h
#
ABtest = CIVARTest(res=res_d,H=H2,h=h,phi=phi,G=G,Dxflag=0)
ABtest$betar
ABtest$alphar
ABtest$VECMR$coefficients
ABtest$LR
1-pchisq(ABtest$LR,14)   ### The Ho of last two are I(0) can be rejected
RR$GABtest$LR
RR <- MIxCIVARData(n=9,p=2,T=209,r=5,k=2,type="const",Bo=NA,Y=NA,D=NA)
## DGP of I(1) and I(0) mixed VECM
plot(ts(RR$Y))
#### testing the mixed VECM via testing the restrictions on beta
res_d <- CIVARData(n=9,p=2,T=209,type="const",crk=4)
res_e = CIVARest(res=res_d)
res_e$Summary
n = 9; crk = 4; k = 2; r = 5
CC  <- c(8,9,17,18)
GG  <- c(19:25,28:34)
G = diag(n*crk); psi=matrix(1,n*crk,1)
### this implies there is no restrictions on the adjustment coefficients alpha
H = diag(n*crk);              H2 = H[,-c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n),CC,GG)]
#### only normalization
h = matrix(0,n*crk,1);         h[c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n)),1] <- 1
phi = matrix(1,ncol(H2),1)
## check consistency of the restrictions    G%*%psi; H2%*%phi + h
#
G%*%psi; H2%*%phi + h
#
ABtest = CIVARTest(res=res_d,H=H2,h=h,phi=phi,G=G,Dxflag=0)
ABtest$betar
ABtest$alphar
ABtest$VECMR$coefficients
ABtest$LR
1-pchisq(ABtest$LR,14)   ### The Ho of last two are I(0) can be rejected
RR$GABtest$LR
RR <- MIxCIVARData(n=9,p=2,T=209,r=5,k=2,type="const",Bo=NA,Y=NA,D=NA)
## DGP of I(1) and I(0) mixed VECM
plot(ts(RR$Y))
RR <- MIxCIVARData(n=9,p=2,T=209,r=5,k=2,type="const",Bo=NA,Y=NA,D=NA)
## DGP of I(1) and I(0) mixed VECM
plot(ts(RR$Y))
RR <- MIxCIVARData(n=9,p=2,T=209,r=5,k=2,type="const",Bo=NA,Y=NA,D=NA)
## DGP of I(1) and I(0) mixed VECM
plot(ts(RR$Y))
RR <- MIxCIVARData(n=9,p=2,T=209,r=5,k=2,type="const",Bo=NA,Y=NA,D=NA)
## DGP of I(1) and I(0) mixed VECM
plot(ts(RR$Y))
RR <- MIxCIVARData(n=9,p=2,T=209,r=5,k=2,type="const",Bo=NA,Y=NA,D=NA)
## DGP of I(1) and I(0) mixed VECM
plot(ts(RR$Y))
RR <- MIxCIVARData(n=9,p=2,T=209,r=5,k=2,type="const",Bo=NA,Y=NA,D=NA)
## DGP of I(1) and I(0) mixed VECM
plot(ts(RR$Y))
RR <- MIxCIVARData(n=9,p=2,T=209,r=5,k=2,type="const",Bo=NA,Y=NA,D=NA)
## DGP of I(1) and I(0) mixed VECM
plot(ts(RR$Y))
#### testing the mixed VECM via testing the restrictions on beta
res_d <- CIVARData(n=9,p=2,T=209,type="const",crk=4)
res_e = CIVARest(res=res_d)
n = 9; crk = 4; k = 2; r = 5
CC  <- c(8,9,17,18)
GG  <- c(19:25,28:34)
G = diag(n*crk); psi=matrix(1,n*crk,1)
### this implies there is no restrictions on the adjustment coefficients alpha
H = diag(n*crk);               H2 = H[,-c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n),CC,GG)]
#### only normalization
h = matrix(0,n*crk,1);         h[c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n)),1] <- 1
phi = matrix(1,ncol(H2),1)
## check consistency of the restrictions    G%*%psi; H2%*%phi + h
#
G%*%psi; H2%*%phi + h
#
ABtest = CIVARTest(res=res_d,H=H2,h=h,phi=phi,G=G,Dxflag=0)
ABtest$betar
ABtest$alphar
ABtest$VECMR$coefficients
ABtest$LR
1-pchisq(ABtest$LR,14)   ### The Ho of last two are I(0) can be rejected
RR$GABtest$LR
#### testing the mixed VECM via testing the restrictions on beta
res_d <- CIVARData(n=9,p=2,T=209,type="const",crk=4)
res_e = CIVARest(res=res_d)
n = 9; crk = 4; k = 2; r = 5
CC  <- c(8,9,17,18)
GG  <- c(19:25,28:34)
G = diag(n*crk); psi=matrix(1,n*crk,1)
### this implies there is no restrictions on the adjustment coefficients alpha
H = diag(n*crk);               H2 = H[,-c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n),CC,GG)]
#### only normalization
h = matrix(0,n*crk,1);         h[c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n)),1] <- 1
phi = matrix(1,ncol(H2),1)
## check consistency of the restrictions    G%*%psi; H2%*%phi + h
#
# G%*%psi; H2%*%phi + h
#
ABtest = CIVARTest(res=res_d,H=H2,h=h,phi=phi,G=G,Dxflag=0)
ABtest$betar
ABtest$alphar
ABtest$VECMR$coefficients
ABtest$LR
1-pchisq(ABtest$LR,14)   ### The Ho of last two are I(0) can be rejected
RR$GABtest$LR
#### testing the mixed VECM via testing the restrictions on beta
res_d <- CIVARData(n=9,p=2,T=209,type="const",crk=4)
res_e = CIVARest(res=res_d)
n = 9; crk = 4; k = 2; r = 5
CC  <- c(8,9,17,18)
GG  <- c(19:25,28:34)
G = diag(n*crk); psi=matrix(1,n*crk,1)
### this implies there is no restrictions on the adjustment coefficients alpha
H = diag(n*crk);               H2 = H[,-c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n),CC,GG)]
#### only normalization
h = matrix(0,n*crk,1);         h[c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n)),1] <- 1
phi = matrix(1,ncol(H2),1)
## check consistency of the restrictions    G%*%psi; H2%*%phi + h
#
# G%*%psi; H2%*%phi + h
#
ABtest = CIVARTest(res=res_d,H=H2,h=h,phi=phi,G=G,Dxflag=0)
ABtest$betar
ABtest$LR
1-pchisq(ABtest$LR,14)   ### The Ho of last two are I(0) can be rejected
RR$GABtest$LR
#### testing the mixed VECM via testing the restrictions on beta
res_d <- CIVARData(n=9,p=2,T=209,type="const",crk=4)
res_e = CIVARest(res=res_d)
n = 9; crk = 4; k = 2; r = 5
CC  <- c(8,9,17,18)
GG  <- c(19:25,28:34)
G = diag(n*crk); psi=matrix(1,n*crk,1)
### this implies there is no restrictions on the adjustment coefficients alpha
H = diag(n*crk);               H2 = H[,-c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n),CC,GG)]
#### only normalization
h = matrix(0,n*crk,1);         h[c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n)),1] <- 1
phi = matrix(1,ncol(H2),1)
## check consistency of the restrictions    G%*%psi; H2%*%phi + h
#
# G%*%psi; H2%*%phi + h
#
ABtest = CIVARTest(res=res_d,H=H2,h=h,phi=phi,G=G,Dxflag=0)
ABtest$betar
ABtest$LR
1-pchisq(ABtest$LR,14)   ### The Ho of last two are I(0) can be rejected
res_d$Y = RR$Y
ABtest = CIVARTest(res=res_d,H=H2,h=h,phi=phi,G=G,Dxflag=0)
ABtest$betar
ABtest$LR
1-pchisq(ABtest$LR,14)   ### The Ho of last two are I(0) can be rejected
RR$GABtest$LR
#### testing the mixed VECM via testing the restrictions on beta
res_d <- CIVARData(n=9,p=2,T=209,type="const",crk=4)
res_e = CIVARest(res=res_d)
n = 9; crk = 4; k = 2; r = 5
CC  <- c(8,9,17,18)
GG  <- c(19:25,28:34)
G = diag(n*crk); psi=matrix(1,n*crk,1)
### this implies there is no restrictions on the adjustment coefficients alpha
H = diag(n*crk);               H2 = H[,-c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n),CC,GG)]
#### only normalization
h = matrix(0,n*crk,1);         h[c(seq(1,(n-r-k)*n,n),seq((n-r-k+1)*n,(n-r)*n,n)),1] <- 1
phi = matrix(1,ncol(H2),1)
## check consistency of the restrictions    G%*%psi; H2%*%phi + h
#
# G%*%psi; H2%*%phi + h
#
ABtest = CIVARTest(res=res_d,H=H2,h=h,phi=phi,G=G,Dxflag=0)
ABtest$betar
ABtest$LR
1-pchisq(ABtest$LR,14)   ### The Ho of last two are I(0) can be rejected
### The null of mixed CIVAR is rejected for pure I(1) data
res_d$Y = RR$Y
ABtest = CIVARTest(res=res_d,H=H2,h=h,phi=phi,G=G,Dxflag=0)
ABtest$betar
ABtest$LR
1-pchisq(ABtest$LR,14)   ### The Ho of last two are I(0) can be rejected
RR$GABtest$LR
### The null of mixed CIVAR is not rejected for mixed data generated from MIxCIVARData
p = matrix(c(2,1,0,0),2,2)
res_d = MRVARData(n=2,p=p,T=300,S=2,SESVI=1,type="none")
max(res_d$Y)
colnames(res_d$Y) = c("R","P")
res_e = MRVARest(res=res_d)
### generalized impulse response function with regime migrations
RF4 = girf_MRVAR_RM_CB(res_e, shock=c(1,1), R=100, nstep=20, Omega_hist = NA, resid_method = "parametric", conf_level=c(0.05,0.95), N=100)
x11()
IRF_list <-IRF_graph(RF4,Names =c("R","P") )
### regime specific impulse response functions without any regime migration
IRF_CB = irf_MRVAR_NM_CB(res_e,nstep=10,comb=NA,irf="gen",runs=200,conf=c(0.05,0.90))
x11()
IRF_list1 <-IRF_graph(IRF_CB[,,,,1])
x11()
IRF_list2 <-IRF_graph(IRF_CB[,,,,2])
##########################################################################
### Global and regional responses
##########################################################################
### The same weighting matrix that is used to aggregate global impulses can
### also be used to aggregate global responses and regional responses.
Global_Response_CB <- irf_GloabalResponse_CB(IRF_CB,comb_all)
##########################################################################
### Global and regional responses
##########################################################################
### The same weighting matrix that is used to aggregate global impulses can
### also be used to aggregate global responses and regional responses.
Global_Response_CB <- irf_GloabalResponse_CB(IRF_CB,comb_all)
##########################################################################
### Global and regional responses
##########################################################################
### The same weighting matrix that is used to aggregate global impulses can
### also be used to aggregate global responses and regional responses.
Global_Response_CB <- irf_GloabalResponse_CB(IRF_CB,comb_all)
######## The following weighting vector are taken from the MRGVAR weighting matrix to form global and regional weights.
#######################################################################################################
# c("BEL","AUT","NLD","NOR","SWE","FIN","DNK","CAN","ESP","ITA","GBR","FRA","DEU","JPN","USA")
#### global and regional shocks
p        <- p_G
res_d    <- MRGVARData(m=2,n=15,p=p,T=370,S=2,SESVI=c((1:15)*2-1),type="const")
res_d$Y  <- FSIIO
res_d$W  <- Wmat_G
res_d$TH <- t(as.matrix(TH_G))
res_e   <- MRGVARest(res_d)
SW   = c(16768,     4919, 3730, 2806, 2678, 2149,   1393,   1826, 313, 267, 579, 512, 428,  524 ,853 )
SWEU = c(16768*0,   4919*0, 3730, 2806, 2678*0, 2149,   1393,   1826*0, 313*0, 267, 579*0, 512*0, 428,  524 ,853 )
SWnorth = c(16768*0,4919*0,3730*0,2806*0,2678*0,2149*0,1393*0,1826*0,313*1,267*1,579*1,512*1,428*0,524*0,853*0 )
SWsouth = c(16768*0,4919*0,3730*0,2806*0,2678*0,2149*1,1393*1,1826*0,313*0,267*0,579*0,512*0,428*0,524*0,853*0 )
SWameri = c(16768*1,4919*0,3730*0,2806*0,2678*0,2149*0,1393*0,1826*1,313*0,267*0,579*0,512*0,428*0,524*0,853*0 )
comb_f = SW2comb(SW,15,2,1)
comb_i = SW2comb(SW,15,2,2)
comb_eu_f =  SW2comb(SWEU,15,2,1)
comb_eu_i =  SW2comb(SWEU,15,2,2)
comb_nt_f =  SW2comb(SWnorth,15,2,1)
comb_nt_i =  SW2comb(SWnorth,15,2,2)
comb_st_f =  SW2comb(SWsouth,15,2,1)
comb_st_i =  SW2comb(SWsouth,15,2,2)
comb_am_f =  SW2comb(SWameri,15,2,1)
comb_am_i =  SW2comb(SWameri,15,2,2)
comb_all = comb_f*0
comb_all[,1]  = comb_f[,1]
comb_all[,2]  = comb_i[,1]
comb_all[,3]  = comb_eu_f[,1]
comb_all[,4]  = comb_eu_i[,1]
comb_all[,5]  = comb_nt_f[,1]
comb_all[,6]  = comb_nt_i[,1]
comb_all[,7]  = comb_st_f[,1]
comb_all[,8]  = comb_st_i[,1]
comb_all[,9]  = comb_am_f[,1]
comb_all[,10] = comb_am_i[,1]
colSums(comb_all)
glw = comb_all[,1:2]
###  Global and regional shocks  ##############################################
###  Note that the first two columns of comb_all generate a global FSI shock and an IP shock respectively.
###  The third and the fourth columns generate an EU FSI and an EU IP shock respectively.
###  The fifth and sixth columns the Northern Europe shocks and so on.
###  The seventh and eighth columns the Southern Europe shocks and so on.
###  Then the next two columns are the American FSI and IP
IRF_CB  = irf_MRGVAR_CB1(res=res_e,nstep=20,comb=comb_all,state=rep(2,15),irf="comb1",runs=20,conf=c(0.05,0.95),NT=1)
iNames <- c("Global FSI","Global IP","EU FSI","EU IP","Northern FSI","Northern IP",
"Southern FSI","Southern IP", "American FSI","American IP")
# FSI responses to a global one unit FSI shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),IName=iNames,impulse=c(1),response=seq(1,30,2),ncol=5)
# IP responses to a global one unit FSI  shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),IName=iNames,impulse=c(1),response=seq(2,30,2),ncol=5)
# FSI responses to an EU one unit FSI shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),IName=iNames,impulse=c(3),response=seq(1,30,2),ncol=5)
# IP responses to a EU one unit FSI shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),IName=iNames,impulse=c(3),response=seq(2,30,2),ncol=5)
# FSI responses to a global one unit IP shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),IName=iNames,impulse=c(2),response=seq(1,30,2),ncol=5)
# IP responses to a global one unit IP  shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),IName=iNames,impulse=c(2),response=seq(2,30,2),ncol=5)
###############################################################################
#############   country specific negatively scaled shocks
Countryshock = matrix(0,30,30)
for (i in 1:15) Countryshock[2*i-1,2*i-1]=-1.5
for (i in 1:15) Countryshock[2*i,2*i]= 2.5
IRF_CB <- irf_MRGVAR_CB1(res=res_e,nstep=20,comb=Countryshock,state=rep(2,15),irf="comb1",runs=20,conf=c(0.05,0.95),NT=1)
x11()  # FSI responses to USA scaled FSI shock (-1.5)
IRF_list <- IRF_graph(IRF_CB[[1]],impulse=c(1),response=seq(1,30,2),ncol=5)
irf_GloabalResponse_CB
library(testMRCIGVAR)
###   Using data from Chen and Semmler (2018)
###
###   country shocks
###
p        <- p_G
res_d    <- MRGVARData(m=2,n=15,p=p,T=370,S=2,SESVI=c((1:15)*2-1),type="const")
res_d$Y  <- FSIIO
res_d$W  <- Wmat_G
res_d$TH <- t(as.matrix(TH_G))
res_e   <- MRGVARest(res_d)
STAT(res_e$Go[,,,1])
STAT(res_e$Go[,,,2])
IRF_CB = irf_MRGVAR_CB1(res=res_e,nstep=20,comb=NA,state=rep(1,15),irf="gen1",runs=20,conf=c(0.05,0.95),NT=1)
# FSI responses to USA FSI shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),impulse=c(1),response=seq(1,30,2),ncol=5)
IRF_list <- IRF_graph(IRF_CB[[2]],Names=names(res_d$Y),impulse=c(1),response=seq(1,30,2),ncol=5)
# FSI responses to USA IP shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),impulse=c(2),response=seq(1,30,2),ncol=5)
IRF_list <- IRF_graph(IRF_CB[[2]],Names=names(res_d$Y),impulse=c(2),response=seq(1,30,2),ncol=5)
p        <- p_G
res_d    <- MRGVARData(m=2,n=15,p=p,T=370,S=2,SESVI=c((1:15)*2-1),type="const")
res_d$Y  <- FSIIO
res_d$W  <- Wmat_G
res_d$TH <- t(as.matrix(TH_G))
res_e   <- MRGVARest(res_d)
SW   = c(16768,     4919, 3730, 2806, 2678, 2149,   1393,   1826, 313, 267, 579, 512, 428,  524 ,853 )
SWEU = c(16768*0,   4919*0, 3730, 2806, 2678*0, 2149,   1393,   1826*0, 313*0, 267, 579*0, 512*0, 428,  524 ,853 )
SWnorth = c(16768*0,4919*0,3730*0,2806*0,2678*0,2149*0,1393*0,1826*0,313*1,267*1,579*1,512*1,428*0,524*0,853*0 )
SWsouth = c(16768*0,4919*0,3730*0,2806*0,2678*0,2149*1,1393*1,1826*0,313*0,267*0,579*0,512*0,428*0,524*0,853*0 )
SWameri = c(16768*1,4919*0,3730*0,2806*0,2678*0,2149*0,1393*0,1826*1,313*0,267*0,579*0,512*0,428*0,524*0,853*0 )
comb_f = SW2comb(SW,15,2,1)
comb_i = SW2comb(SW,15,2,2)
comb_eu_f =  SW2comb(SWEU,15,2,1)
comb_eu_i =  SW2comb(SWEU,15,2,2)
comb_nt_f =  SW2comb(SWnorth,15,2,1)
comb_nt_i =  SW2comb(SWnorth,15,2,2)
comb_st_f =  SW2comb(SWsouth,15,2,1)
comb_st_i =  SW2comb(SWsouth,15,2,2)
comb_am_f =  SW2comb(SWameri,15,2,1)
comb_am_i =  SW2comb(SWameri,15,2,2)
comb_all = comb_f*0
comb_all[,1]  = comb_f[,1]
comb_all[,2]  = comb_i[,1]
comb_all[,3]  = comb_eu_f[,1]
comb_all[,4]  = comb_eu_i[,1]
comb_all[,5]  = comb_nt_f[,1]
comb_all[,6]  = comb_nt_i[,1]
comb_all[,7]  = comb_st_f[,1]
comb_all[,8]  = comb_st_i[,1]
comb_all[,9]  = comb_am_f[,1]
comb_all[,10] = comb_am_i[,1]
colSums(comb_all)
glw = comb_all[,1:2]
IRF_CB  = irf_MRGVAR_CB1(res=res_e,nstep=20,comb=comb_all,state=rep(2,15),irf="comb1",runs=20,conf=c(0.05,0.95),NT=1)
iNames <- c("Global FSI","Global IP","EU FSI","EU IP","Northern FSI","Northern IP",
"Southern FSI","Southern IP", "American FSI","American IP")
# FSI responses to a global one unit FSI shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),IName=iNames,impulse=c(1),response=seq(1,30,2),ncol=5)
# IP responses to a global one unit FSI  shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),IName=iNames,impulse=c(1),response=seq(2,30,2),ncol=5)
# FSI responses to an EU one unit FSI shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),IName=iNames,impulse=c(3),response=seq(1,30,2),ncol=5)
# IP responses to a EU one unit FSI shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),IName=iNames,impulse=c(3),response=seq(2,30,2),ncol=5)
# FSI responses to a global one unit IP shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),IName=iNames,impulse=c(2),response=seq(1,30,2),ncol=5)
# IP responses to a global one unit IP  shock
IRF_list <- IRF_graph(IRF_CB[[1]],Names=names(res_d$Y),IName=iNames,impulse=c(2),response=seq(2,30,2),ncol=5)
Countryshock = matrix(0,30,30)
for (i in 1:15) Countryshock[2*i-1,2*i-1]=-1.5
for (i in 1:15) Countryshock[2*i,2*i]= 2.5
IRF_CB <- irf_MRGVAR_CB1(res=res_e,nstep=20,comb=Countryshock,state=rep(2,15),irf="comb1",runs=20,conf=c(0.05,0.95),NT=1)
x11()  # FSI responses to USA scaled FSI shock (-1.5)
IRF_list <- IRF_graph(IRF_CB[[1]],impulse=c(1),response=seq(1,30,2),ncol=5)
x11()  # FSI responses to USA scaled IP shock  (2.5)
IRF_list <- IRF_graph(IRF_CB[[1]],impulse=c(2),response=seq(1,30,2),ncol=5)
### concertA matrix specifies different degrees of the concerted actions
concertedA = matrix(0,30,30)
for (i in 1:15 ) for ( j in 1:10 )   concertedA[2*i-1,j] = -1+(j-1)*0.1
IRF  = irf_MRGVAR(res=res_e,nstep=20,comb=concertedA,state=rep(2,15),irf="concertc")
IRF_CB = irf_MRGVAR_CB1(res=res_e,nstep=20,comb=concertedA,state=rep(2,15),irf="concertc",runs=20,conf=c(0.05,0.95),NT=1)
# FSI responses to concerted actions in FSI (1: each country with one unit)
IRF_list <- IRF_graph(IRF_CB[[1]],impulse=c(1),response=seq(1,30,2),ncol=5)
# FSI responses to concerted actions in FSI (2: each country with 0.9 unit)
IRF_list <- IRF_graph(IRF_CB[[1]],impulse=c(2),response=seq(1,30,2),ncol=5)
library(testMRCIGVAR)
#### MRVAR with exogenous variables X is (T x k x S ) array, allowing
#### different exogenous variables in different regimes. k is the number of exogenous variables.
X1=matrix(rnorm(2*300),300,2)
X2=matrix(rnorm(2*300),300,2)
XX = cbind(X1,X2); dim(XX) = c(300,2,2)
p = matrix(c(2,1,2,2),2,2)
res_d = MRVARData(n=2,p=p,T=300,S=2,SESVI=1,type="exog1",X=XX)
max(res_d$Y)
res_e = MRVARest(res=res_d)
res_e$Summary
#### If the number of exogenous variables are different in two regimes, the excess columns
#### can be filled with zeros.
X=matrix(rnorm(2*300),300,2)
XX = cbind(X,X); dim(XX) = c(300,2,2);XX[,2,2]=0
p = matrix(c(2,1,2,2),2,2)
res_d = MRVARData(n=2,p=p,T=300,S=2,SESVI=1,type="exog1",X=XX)
max(res_d$Y)
res_e = MRVARest(res=res_d)
res_e$Summary
X1=matrix(rnorm(2*300),300,2)
X2=matrix(rnorm(2*300),300,2)
XX = cbind(X1,X2); dim(XX) = c(300,2,2)
p = matrix(c(2,1,2,2),2,2)
res_d = MRVARData(n=2,p=p,T=300,S=2,SESVI=1,type="exog1",X=XX)
max(res_d$Y)
res_e = MRVARest(res=res_d)
res_e$Summary
X=matrix(rnorm(2*300),300,2)
XX = cbind(X,X); dim(XX) = c(300,2,2);XX[,2,2]=0
p = matrix(c(2,1,2,2),2,2)
res_d = MRVARData(n=2,p=p,T=300,S=2,SESVI=1,type="exog1",X=XX)
max(res_d$Y)
res_e = MRVARest(res=res_d)
res_e$Summary
T = 200
res_d <- CCIVARData(n1=4,n2=3,crk=3,p=3,T=T,type="const")
res_e <- CCIVARest(res=res_d)
res_e$Summary
res_e$tst$beta
T = 200
res_d <- CCIVARData(n1=4,n2=3,crk=3,p=3,T=T,type="const")
res_e <- CCIVARest(res=res_d)
res_e$Summary
res_e$tst$beta
T = 200
res_d <- CCIVARData(n1=4,n2=3,crk=3,p=3,T=T,type="const")
res_e <- CCIVARest(res=res_d)
res_e$Summary
res_e$tst$beta
T = 200
res_d <- CCIVARData(n1=4,n2=3,crk=3,p=3,T=T,type="const")
res_e <- CCIVARest(res=res_d)
res_e$Summary
res_e$tst$beta
T = 200
res_d <- CCIVARData(n1=4,n2=3,crk=3,p=3,T=T,type="const")
res_e <- CCIVARest(res=res_d)
res_e$Summary
res_e$tst$beta
T = 200
res_d <- CCIVARData(n1=4,n2=3,crk=3,p=3,T=T,type="const")
res_e <- CCIVARest(res=res_d)
res_e$Summary
res_e$tst$beta
T = 200
res_d <- CCIVARData(n1=4,n2=3,crk=3,p=3,T=T,type="const")
res_e <- CCIVARest(res=res_d)
#res_e$Summary
#res_e$tst$beta
m = 2
n = 3
p = c(2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0); dim(p) = c(5,3,2)
p = p[1:n,,]; p[,1,] = 3; p[,2,] = 2
TH = c(1:n)*0; dim(TH) = c(1,n)
SESVI=rep(1,3,5)
r  = rep(1,n)
## case of n = 3, m = 2, S = 2
res_d <- MRCIGVARData(m=2,n=3,p=p,TH=TH,T=100,S=2, SESVI=c(1,3,5),r=rep(1,3),Ncommtrend=1)    ## m: number of variables, n: number of countries
max(abs(res_d$Y))
STAT(res_d$Go[,,,2])
STAT(res_d$Go[,,,1])
res_e  = MRCIGVARestm(res=res_d)
T= 200
XX = matrix(rnorm(T*6*2),T*6,2)
dim(XX) = c(T,2,3,2)
XX = XX*10
p[,3,]=2
res_d <- MRCIGVARData(m=2,n=3,p=p,TH=TH,T=T,S=2, SESVI=c(1,3,5),type="exog0",r=rep(1,3),Ncommtrend=1,X=XX)    ## m: number of variables, n: number of countries
max(abs(res_d$Y))
STAT(res_d$Go[,,,2])
STAT(res_d$Go[,,,1])
res_e  = MRCIGVARestm(res=res_d)
res_e$Summary
STAT(res_e$Go[,,,2])
STAT(res_e$Go[,,,1])
IRF_CB = irf_MRCIGVAR_CB(res=res_e, nstep=10, comb=NA, state = c(2,1,1), irf = "gen1", runs = 20, conf = c(0.05, 0.95), NT = 1)
str(IRF_CB)
IRF_g = IRF_graph(IRF_CB[[1]])
m = 2
n = 3
p = c(2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0); dim(p) = c(5,3,2)
p = p[1:n,,]; p[,1,] = 3; p[,2,] = 2
TH = c(1:n)*0; dim(TH) = c(1,n)
SESVI=rep(1,3,5)
r  = rep(1,n)
res_d <- MRCIGVARData(m=2,n=3,p=p,TH=TH,T=100,S=2, SESVI=c(1,3,5),r=rep(1,3),Ncommtrend=1)    ## m: number of variables, n: number of countries
max(abs(res_d$Y))
STAT(res_d$Go[,,,2])
STAT(res_d$Go[,,,1])
res_e  = MRCIGVARestm(res=res_d)
T= 200
XX = matrix(rnorm(T*6*2),T*6,2)
dim(XX) = c(T,2,3,2)
XX = XX*10
p[,3,]=2
res_d <- MRCIGVARData(m=2,n=3,p=p,TH=TH,T=T,S=2, SESVI=c(1,3,5),type="exog0",r=rep(1,3),Ncommtrend=1,X=XX)    ## m: number of variables, n: number of countries
max(abs(res_d$Y))
STAT(res_d$Go[,,,2])
res_d <- MRCIGVARData(m=2,n=3,p=p,TH=TH,T=100,S=2, SESVI=c(1,3,5),r=rep(1,3),Ncommtrend=1)    ## m: number of variables, n: number of countries
max(abs(res_d$Y))
res_d <- MRCIGVARData(m=2,n=3,p=p,TH=TH,T=100,S=2, SESVI=c(1,3,5),r=rep(1,3),Ncommtrend=1)    ## m: number of variables, n: number of countries
max(abs(res_d$Y))
STAT(res_d$Go[,,,2])
STAT(res_d$Go[,,,1])
